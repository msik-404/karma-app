# karma-app-gateway

Gateway microservice for karma-app. karma-app-gateway is http server which exposes rest endpoints
and communicate with other microservices to perform operations. karma-app-gateway supports caching by using redis.

Check out other karma-app microservices:

- [karma-app-posts]
- [karma-app-users]

# Technologies used

- Java 21
- Redis
- Docker
- [gRPC]
- Java spring
- spring-boot-starter-web
- spring-boot-starter-data-redis
- spring-boot-starter-security
- spring-boot-starter-validation
- spring-boot-starter-hateoas
- spring-boot-starter-test
- [spring-boot-testcontainers]
- junit-jupiter
- [grpc-java]
- [protovalidate-java]
- [jjwt]
- lombok
- OpenAPI
- Swagger

# gRPC, Protobuf and protovalidate

[gRPC] is a modern open source high performance Remote Procedure Call (RPC) framework that can run in any environment. 
gRPC simplifies microservices API implementation and later the usage of the API. gRPC is self-documenting, all available 
service methods and message structures can be inside proto files under [proto folder].

In this project to help with message validation [protovalidate-java] is used. This project significantly simplifies 
validation of messages and reduces the time required to build stable system. Additionally potential user of this 
microservice can see which fields are required and what constraints need to be met to build valid message.

# Features

## REST API

The API documentation follows OpenAPI specification. API docs without running the app can be inspected:

- In raw form: [api-docs.yaml].
- In UI: [Swagger UI]

With running the app under:

- http://localhost:8080/swagger-ui/index.html - This allows the app to be tests.
- http://localhost:8080/v3/api-docs

### Notes

#### Bearer Token

Endpoints that have `/user`, `/mod`, `/admin` prefix require user to be authenticated. User needs to set
`HTTP Authorization header` to `Berear JWT_STRING`. JWT_STRING is acquired from login endpoint.

JWT has two claims set:

- sub (subject) to logged-in user id which is SOME_24_CHAR_HEX_STRING.
- exp (expiration time) to one hour.

#### SwaggerUI and create new post endpoint

SwaggerUI incorrectly generates request for creating new posts. This request uses `multipart-form`. One of the form
parts sends json object and requires `type=application/json` to be set. SwaggerUI does not do this, and sets 
`type=application/octet-stream`by default. This issue has been addressed [here][SwaggerUI-fix] so that 
`type=application/octet-stream` is accepted.

Correct request generated by Postman:

```
curl --location 'localhost:8080/user/posts' \
--header 'Authorization: Bearer ${JWT_STRING}' \
--form 'postCreationRequest="{\"text\": \"Some basic text\", \"headline\": \"Some basic headline\"}";type=application/json' \
--form 'image=@"/path/to/image"'
```

## Exception encoding

When some exception which is not critical is thrown on the backend side, it is being encoded and passed with appropriate
gRPC code to the caller. Each exception has its unique identifier. With this it can be decoded on the caller side.
In this setup client side can use the same exception classes as backend.

Simple [encoding class] which simply inserts "exceptionId EXCEPTION_ID" at the begging of error message. This 
EXCEPTION_ID can be parsed with simple regex.

Each encodable exception must implement [EncodableException]and [GrpcStatusException].

karma-app-gateway has [decoding class] implemented, which takes encoded message and returns appropriate exception.

## Cache

Most of the endpoints use cache in some way but primarily cache is used for fetching any range of posts between [0 -
[MAX_CACHED_POSTS]] as long as no filtering rules are applied (filter by username or visibility other than active). Each 
post state change which is persisted in database is being reflected to the cache. That is post score and visibility changes. 
Rating posts high enough might make them present in cache. Making post visibility hidden or deleted evicts it from cache 
if it was cached prior. Every post get cached if max cached posts count is not yet reached.

#### How is it implemented?

I use several redis structures for this:

- [Redis sorted sets] (ZSet) for preserving top posts rating (all cached posts). ZSet is set under the 
  [KARMA_SCORE_ZSET_KEY]. ZSet contains Keys in [post_key] format, each post_key has score which is post karmaScore. 
  Score is being updated in real time, so that post score does not become stale. KARMA_SCORE_ZSET_KEY expires after 
  [TIMEOUT].

- [Redis hashes] for storing all post non-image data. Each field is post_key and value is json serialized [PostDto.java].
  There are as many fields as there are keys in ZSet. This hash is set under the [POST_HASH_KEY], it expires after TIMEOUT.

- [Redis Strings] are used for storing image data. Each image binary data is found under the [post_image_key].
  Each post_image_key has expiration time set to TIMEOUT which is one hour. post_image_key is set once the image is 
  requested for the first time. Expiration time is reset each time the data is requested within TIMEOUT.

The cache uses this [redis.conf]. The most important things about it are that is uses: [AOF and RDB].

The cache's code uses [Redis pipelining] when more than single operation needs to be preformed. This improves efficiency, 
by reducing required number of request.

Because ZSet [ZRANGE] cannot be trivially used for getting key-set paginated values, solution had to be found.
If reader is interested in details look inside [findNextNCached] method code and comments.

#### Note

Maximum amount of posts cached can exceed [MAX_CACHED_POSTS] this is because of the second rule for caching during rating 
posts positively:

```
Post will get cached if one of these two things take place at the time of rating the post:
- first: cache is not yet full.
- second: post karma score after rating is higher than the lowest score of a post in cache.
```

But this would be actually rare because all cached posts get expired after [TIMEOUT].

# Building the project

To get target folder and build the project with maven simply run:

```
./mvnw clean package -DskipTests
```

If one would like to build the project with running the tests, one must have docker installed on their machine and run:

```
./mvnw clean package
```

# Tests

Docker is required to run tests locally because I use [Testcontainers for Java].

Code that is directly communicating with redis is fully tested with integration tests. Test reside in [src/test].

The rest of the code was tested manually using postman.

[spring-boot-testcontainers]: https://spring.io/blog/2023/06/23/improved-testcontainers-support-in-spring-boot-3-1
[grpc-java]: https://github.com/grpc/grpc-java
[protovalidate-java]: https://github.com/bufbuild/protovalidate-java
[jjwt]: https://github.com/jwtk/jjwt#install-jdk-maven
[gRPC]: https://grpc.io/
[Redis sorted sets]: https://redis.io/docs/data-types/sorted-sets/
[Redis hashes]: https://redis.io/docs/data-types/hashes/
[Redis Strings]: https://redis.io/docs/data-types/strings/
[AOF and RDB]: https://redis.io/docs/management/persistence/
[Redis pipelining]: https://redis.io/docs/manual/pipelining/
[ZRANGE]: https://redis.io/commands/zrange/
[Testcontainers for Java]: https://java.testcontainers.org/

[karma-app-posts]: https://github.com/msik-404/karma-app/tree/main/karma-app-posts
[karma-app-users]: https://github.com/msik-404/karma-app/tree/main/karma-app-users
[proto folder]: https://github.com/msik-404/karma-app/tree/main/karma-app-gateway/src/main/proto
[api-docs.yaml]: https://github.com/msik-404/karma-app/blob/main/api-docs.yaml
[Swagger UI]: https://petstore.swagger.io/?url=https://raw.githubusercontent.com/msik-404/karma-app/main/api-docs.yaml
[SwaggerUI-fix]: https://github.com/msik-404/karma-app/blob/main/karma-app-gateway/src/main/java/com/msik404/karmaappgateway/docs/SwaggerConfiguration.java#L31
[encoding class]: https://github.com/msik-404/karma-app/blob/main/karma-app-gateway/src/main/java/com/msik404/karmaappgateway/grpc/client/encoding/ExceptionEncoder.java
[EncodableException]: https://github.com/msik-404/karma-app/blob/main/karma-app-gateway/src/main/java/com/msik404/karmaappgateway/grpc/client/encoding/EncodableException.java
[GrpcStatusException]: https://github.com/msik-404/karma-app/blob/main/karma-app-gateway/src/main/java/com/msik404/karmaappgateway/grpc/client/exception/GrpcStatusException.java
[decoding class]: https://github.com/msik-404/karma-app/blob/main/karma-app-gateway/src/main/java/com/msik404/karmaappgateway/grpc/client/encoding/ExceptionDecoder.java
[MAX_CACHED_POSTS]: https://github.com/msik-404/karma-app/blob/main/karma-app-gateway/src/main/java/com/msik404/karmaappgateway/post/cache/PostRedisCache.java#L37
[KARMA_SCORE_ZSET_KEY]: https://github.com/msik-404/karma-app/blob/main/karma-app-gateway/src/main/java/com/msik404/karmaappgateway/post/cache/PostRedisCache.java#L28
[post_key]: https://github.com/msik-404/karma-app/blob/main/karma-app-gateway/src/main/java/com/msik404/karmaappgateway/post/cache/PostRedisCache.java#L44
[TIMEOUT]: https://github.com/msik-404/karma-app/blob/main/karma-app-gateway/src/main/java/com/msik404/karmaappgateway/post/cache/PostRedisCache.java#L32
[PostDto.java]: https://github.com/msik-404/karma-app/blob/main/karma-app-gateway/src/main/java/com/msik404/karmaappgateway/post/dto/PostDto.java
[POST_HASH_KEY]: https://github.com/msik-404/karma-app/blob/main/karma-app-gateway/src/main/java/com/msik404/karmaappgateway/post/cache/PostRedisCache.java#L29
[post_image_key]: https://github.com/msik-404/karma-app/blob/main/karma-app-gateway/src/main/java/com/msik404/karmaappgateway/post/cache/PostRedisCache.java#L49
[redis.conf]: https://github.com/msik-404/karma-app/blob/main/karma-app-gateway/redis.conf
[findNextNCached]: https://github.com/msik-404/karma-app/blob/main/karma-app-gateway/src/main/java/com/msik404/karmaappgateway/post/cache/PostRedisCache.java#L195
[src/test]: https://github.com/msik-404/karma-app/tree/main/karma-app-gateway/src/test